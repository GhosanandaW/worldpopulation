<!doctype html>
<html>

<head>
<title>World Population, Growth, and Demographic Changes Throughout Time (1950 to 2021)</title>
<meta name="description" content="Answering the qustion: What is the world population demographic and its (growth/decline) trend throughout time?">
<meta name="keywords" content="World population demographic and trend">
<style>
    html
{
    margin: 0px; padding: 0px
}

body {
    margin: 0px; 
    padding: 0px;
    /* background-color: rgb(243, 237, 237); */
}

    .center{
        margin: auto;
  /* border: 3px solid blue; */
  padding: 10px;
  text-align: center;
  vertical-align: center;
  align-content: center;
    }

    .title{
        background-color: bisque;
        color: brown;
        border: 2px solid rgb(207, 201, 201); 
        padding:0px ;
        margin:0px ;

    }

    .wholeBody{

    }
    .container {
    /* background-color:#2E4272; */
    display:flex;
    text-align: center;
  vertical-align: center;
  align-content: center;
    margin-top: 2.5%;
}
.fixed {
    /* background-color:#4F628E; */
    width: 60%;
}
.flex-left {
    /* background-color:#7887AB; */
    flex-grow: 1;
}


    .allContent {
        margin: auto;
        /* border: 3px solid black; */
        padding:0px ;
        margin:0px ;
    }
    #D3container{
        margin: auto;
        /* border: 3px solid green; */
        padding: 10px;
            }

    .narrative{
        width:20%;
        /* background-color:red; */
    }

    .rightGutter{
        width:20%;
        /* background-color:yellow; */
    }

</style>

</head>

<body class="wholeBody">
<div class="allContent"> 
    <div class="title center">
        <h1>World Population, Growth, and Demographic Changes Throughout Time (1950 to 2021)</h1>
        </div>

    <div class="mainContainer">
    <div id="D3container" class="container">
    <div id="D3Narrative" class="narrative"></div>
    <div id="D3MainContent" class="fixed" ></div>
    <div id="D3Misc" class="rightGutter"></div>
    </div>
    </div>



</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-annotation/2.5.1/d3-annotation.min.js"></script>
<script type="module">   
// Parts of the codes are inspired and referred from: https://d3-graph-gallery.com/scatter.html
// Scales and legend inspired and referred from: https://observablehq.com/@d3/continuous-scales
 var data;
 var dataPerYear;
 var region;
 var yearTest=['1950'];//default value of year
var yearMartini=['1950','1965','1981','1997','2021']
//  var yearMartini=['1950','1975','2000','2021']
 var yearsAll=[];
 var firstSceneBool=true;
 var circleRadiusScale;
 var color;
 var svg;
 var svgLegend;
 var xAxisDomain;
var xAxisRange;
var yAxisDomain;
var yAxisRange;
var xAxis;
var yAxis;
var globalTop3Centroid=[];
var globalMedian3Centroid=[];
var annotationVariables;
var globalCircle;



 async function dataRequestandInit(yearList)
 {
    console.log('data init running, waiting for data HTTP request')
    data=await d3.csv('./joined_world_population_data.csv');
    dataPerYear=d3.group(data,d=>d.Year);
    console.log('data init running, waiting for data HTTP request')
    console.log (data);
    console.log (dataPerYear);
        //scales

    //circle scale to indicate relative size of population
    circleRadiusScale = d3.scaleSqrt()
    .domain([0,d3.max(data,function(d) { return d['Total Population, as of 1 July (thousands)']; })])
    .range([0,4])

    //color scale to separate by regions
 color = d3.scaleOrdinal()
    .domain([...Array(7).keys()])
    .range(d3.schemeCategory10)

    for (let i = 1950; i < 2022; i++) {
        yearsAll.push(i.toString());
}
    
    console.log ('overall year is: ', yearsAll)

    //main body
console.log('entering yearsAll loop')
yearList.forEach( (eachYear)=>{
    setTimeout(async () => {
  console.log("Delaying for 5 second.");
  await mainRendering(eachYear);
  console.log('await for mainRendering for the year finished', eachYear)
}, "5000")
}
)
}

dataRequestandInit(yearMartini);

//annotation
var type = d3.annotationCalloutCircle


    //layout
    var width = 600;
    var height = 600;
    var marginTop = 30;
    var marginRight = 6;
    var marginBottom = 55;
    var marginLeft = 60;
    var axisSyncDomain=60;



    //legend layout
    var legendWidth = 200;
    var legendHeight = height + marginTop + marginBottom
    var legendMarginLeft=20;
    var legendMarginRight=20;

    async function mainRendering(year)
    {
    if (year!='1950'){
    console.log('current year is', year);
    firstSceneBool==false;
    d3.selectAll(".dynamicComponent").remove();
}

    if (year=='1950'){
    //required init
    //create svg component
    svg = d3.select("#D3MainContent")
      .append("svg")
      .attr("class", "svgD3MainContent") 
        .attr("width", width + marginLeft + marginRight)
        .attr("height", height + marginTop + marginBottom)
      .append("g")
        .attr("transform", `translate(${marginLeft}, ${marginTop})`)

         globalCircle = svg.append('circle')
          .attr('fill', 'red')
          .attr('r', 6)
          .attr('style','position: relative; z-index: 99;')
          .raise()

//axis setup
// var xAxisDomain = [0, d3.max(data,function(d) { return +d['Crude Birth Rate (births per 1,000 population)']; })];
xAxisDomain = [0, axisSyncDomain];
console.log(xAxisDomain);
var xAxisRange=[0,width];
console.log(xAxisRange);


// var yAxisDomain=[0, d3.max(data,function(d) { return +d['Crude Death Rate (deaths per 1,000 population)']; })];
 yAxisDomain=[0, axisSyncDomain];
console.log (yAxisDomain);
 yAxisRange=[height,0];
console.log (yAxisRange);


//create axis
 xAxis=d3.scaleLinear().domain(xAxisDomain).range(xAxisRange);
svg.append("g")
    .attr("class", "xAxis") 
    .attr("transform", `translate(0, ${height})`)
    .call(d3.axisBottom(xAxis));
    


 yAxis=d3.scaleLinear().domain(yAxisDomain).range(yAxisRange);
svg.append("g")
    .call(d3.axisLeft(yAxis));


// Include X axis title:
svg.append("text")
    .attr("text-anchor", "end")
    .attr("x", width)
    .attr("y", height + marginTop + 20)
    .text('Crude Death Rate (deaths per 1,000 population)');

// Include Y axis title:
svg.append("text")
    .attr("text-anchor", "end")
    .attr("transform", "rotate(-90)")
    .attr("y", -marginLeft+20)
    .attr("x", -marginTop)
    .text('Crude Birth Rate (births per 1,000 population)')


// //color scale to separate by regions
// const color = d3.scaleOrdinal()
//     .domain([...Array(7).keys()])
//     .range(d3.schemeCategory10)

//circle scale to indicate relative size of population
// const circleRadiusScale = d3.scaleSqrt()
//     .domain([0,d3.max(data,function(d) { return d['Total Population, as of 1 July (thousands)']; })])
//     .range([0,4])

//create the legend for circles
// var circleLegendValues=[0,d3.max(data,function(d) { return d['Total Population, as of 1 July (thousands)'];})]
var circleLegendValues=[0,500000,1000000,1425862]
console.log ('generating legend for circles size')

svgLegend = d3.select("#D3MainContent")
.append("svg")
.attr("class", "svgLegend")
        .attr("width", legendWidth)
        .attr("height", height + marginTop + marginBottom)
      .append("g")
        .attr("transform", `translate(${legendWidth/2},0)`)
        // .attr("transform", `translate(${legendWidth/2}, ${(height+ marginTop + marginBottom)/2})`)


console.log('circleLegendValues',circleLegendValues)
var circleLegend = svgLegend.append("g")
    .attr("class", "circleLegend")
    .selectAll('circle')
    .data(circleLegendValues)
    .enter()
    .append("g")
    .append("circle")
    .attr("cx", 0)
    .attr("cy", (d) => {return (legendHeight - marginBottom - circleRadiusScale(d))})
    .attr("r",  (d) => {return circleRadiusScale(d)})
    .attr("stroke", "black")
    .attr("stroke-width", 1.5)
    .attr("fill", "none");
    
var circleLegendText=svgLegend.append("g")
    .attr("style", "dominant-baseline: hanging; text-anchor: middle;") // Text alignment and styling
    .attr("font-size", 10)
    .selectAll("text")
    .data(circleLegendValues)
    .join("text")
    .attr("dy", "0.35em")
    .attr("x",0)
    .attr("y", d => legendHeight - marginBottom - 2 * circleRadiusScale(d) + 3) // Position text below circle
    .text(d=>d); // Display the data value

    var circleLegendTitle=svgLegend.append("g")
    .attr("class", "circleLegendTitle")
    .attr("style", "dominant-baseline: hanging; text-anchor: middle;  font-weight: 900;") // Text alignment and styling
    .attr("font-size", 10)
    .selectAll("text")
    .data([circleLegendValues[circleLegendValues.length-1]])
    .join("text")
    .attr("dy", "0.35em")
    .attr("x",0)
    .attr("y", d => legendHeight - marginBottom - 2 * circleRadiusScale(d) + 3 - 25) // Position text below circle
    .text('Size of Population'); // Display the data value

// svg.append('g')
//     .selectAll("circle")
//     .data(dataPerYear.get('1950'))
//     .enter()
//     .append("circle")
//     .attr('cx',(d,i)=>{return xAxis(d['Crude Death Rate (deaths per 1,000 population)'])})
//     .attr('cy',(d,i)=>{return yAxis(d['Crude Birth Rate (births per 1,000 population)'])})
//     .attr('r',(d,i)=>{return circleRadius(d['Total Population, as of 1 July (thousands)'])})
//     .attr("stroke", "steelblue")
//       .attr("stroke-width", 1.5)
//       .attr("fill", (d,i)=>{console.log (d['Region']);return color(d['Region'])})

//Create increasing/declining population reference line
const referenceLineData = [[0, 0], [axisSyncDomain, axisSyncDomain]]; // Adjust points as needed
const lineGenerator = d3.line()
  .x(d => xAxis(d[0]))
  .y(d => yAxis(d[1]));

svg.append("path")
  .attr("d", lineGenerator(referenceLineData))
  .attr("stroke", "red") // Adjust color as needed
  .attr("stroke-dasharray", "5,5"); // Optional: dashed line
//required init ends
    }



//MAIN DYNAMIC COMPONENT, to be destroyed for each sequence of year
//Add graph title 
svg.append("text")
        .attr("x", (width / 2))             
        .attr("y", 0 - (marginTop / 2))
        .attr("text-anchor", "middle")
        .attr("class", "dynamicComponent")
        .style("font-size", "16px") 
        .style("text-decoration", "underline")  
        .text("Birth Rate to Death Rate Scaterplot:"+" YEAR "+year);

//create data points on graph
svg.append('g')
    .selectAll("circle")
    .data(dataPerYear.get(year))
    .enter()
    .append("circle")
    .attr("class", "dynamicComponent")
    .attr('cx',(d,i)=>{return xAxis(d['Crude Death Rate (deaths per 1,000 population)'])})
    .attr('cy',(d,i)=>{return yAxis(d['Crude Birth Rate (births per 1,000 population)'])})
    .attr('r',(d,i)=>{return circleRadiusScale(d['Total Population, as of 1 July (thousands)'])})
    .attr("stroke", "steelblue")
      .attr("stroke-width", 1.5)
      .attr("fill", (d,i)=>{console.log (d['Region']);return color(d['Region'])})

//Create label for the data points
      svg.append("g")
      .attr("font-family", "sans-serif")
      .attr("font-size", 10)
      .attr("class", "dynamicComponent")
    .selectAll("text")
    .data(dataPerYear.get(year))
    .join("text")
      .attr("dy", "0.35em")
      .attr("x", (d,i)=> {return xAxis(d['Crude Death Rate (deaths per 1,000 population)'])+7})
      .attr("y", (d,i)=> {return yAxis(d['Crude Birth Rate (births per 1,000 population)'])})
      .text(d => d['Region, subregion, country or area *'])
      .each(function(d, i, nodes) {
    const label = this;
    const otherLabels = nodes.slice(0, i);
    // const circle = svg.selectAll('circle').filter(circleData => {console.log (circleData,d,circleData === d); return circleData === d}); 
    // console.log (svg.selectAll('circle').each((child)=>{console.log(child,d,child===d)}))
    // console.log (svg.selectAll('circle'))
    // console.log (circle)
    // console.log(d)
    // console.log (d['Region, subregion, country or area *'])
    // console.log (circle.size())
    // console.log (circle.nodes())
    // console.log (d)
    const circleNodes = svg.selectAll('circle').nodes()
    console.log (circleNodes)


    // if (circle.size() === 1) { // Check if circle exists
    //   var circleBBox = circle.node().getBBox();
    //   console.log (circleBBox)
    //   // ... your code for checking overlap and adjusting positions
    // } 
    // else {
    //   console.error("Circle not found for label:", d);
    // }
    let adjusted = false;

    // Adjust label position if overlapping
    otherLabels.forEach(otherLabel => {
      if (isOverlapping(label, otherLabel)) {
        // Adjust label position here (e.g., move it down or to the side)
        console.log ('is overlapping between label and otherLabel', label, otherLabel)
        label.setAttribute('y', label.getAttribute('y') - 5); // Simple adjustment, you can refine this
        adjusted = true;
      }
    });

    circleNodes.forEach(circleNode => {
      if (isOverlapping(label, circleNode)) {
        // Adjust label position here (e.g., move it down or to the side)
        console.log ('is overlapping between label and otherLabel', label, circleNode)
        label.setAttribute('y', label.getAttribute('y') - 5); // Simple adjustment, you can refine this
        adjusted = true;
      }
    });

    // circleNode.forEach(circleNodeChild => {
    //   if (isOverlapping(label, circleNodeChild)) {
    //     // Adjust label position here (e.g., move it down or to the side)
    //     console.log ('is overlapping between circleNode and label', label,circle,circleNode)
    //     label.setAttribute('y', label.getAttribute('y') - 5); // Simple adjustment, you can refine this
    //     adjusted = true;
    //   }
    // });

    // If label was adjusted, check for new overlaps and adjust again if needed
    if (adjusted) {
        let secondAdjusted=false;

      otherLabels.forEach(otherLabel => {
        if (isOverlapping(label, otherLabel)) {
          secondAdjusted=true
        }
      });

      circleNodes.forEach(circleNode => {
      if (isOverlapping(label, circleNode)) {
        secondAdjusted=true
      }
      if (secondAdjusted===true){
        label.remove();
      }
    });

    }
  });

//Function to check element overlap
function isOverlapping(element1, element2) {
  const bbox1 = element1.getBBox();
  const bbox2 = element2.getBBox();
  return !(bbox1.x + bbox1.width < bbox2.x ||
           bbox1.x > bbox2.x + bbox2.width ||
           bbox1.y + bbox1.height < bbox2.y ||
           bbox1.y > bbox2.y + bbox2.height);
}



//Create density map
  // Prepare a color palette
  const colorDensityMap = d3.scaleLinear()
      .domain([0,0.001]) // Points per square pixel.
      .range(["#FDE725", "#440154"])

  // compute the density data
  const densityData = d3.contourDensity()
    .x(function(d) { console.log (d['Crude Death Rate (deaths per 1,000 population)']); return xAxis(d['Crude Death Rate (deaths per 1,000 population)']); })
    .y(function(d) { console.log(d['Crude Birth Rate (births per 1,000 population)']);return yAxis(d['Crude Birth Rate (births per 1,000 population)']); })
    .size([width, height])
    .bandwidth(7)
    (dataPerYear.get(year))

    console.log ('density data is: ',densityData)

  // show the shape of density map
  svg.insert("g", "g")
  .attr("class", "dynamicComponent")
    .selectAll("path")
    .data(densityData)
    .enter().append("path")
      .attr("d",d3.geoPath())
      .attr("fill", function(d) { console.log (d.value,colorDensityMap(d.value),d3.geoPath()); return colorDensityMap(d.value); }).attr('opacity', "0.2")



// var densestContour = densityData.reduce((a, b) => a.value > b.value ? a : b);
// var densestContour= densityData.reduce((acc, curr) => acc + curr.value, 0) / densityData.length;
// console.log(densestContour.coordinates[0])
// console.log(densityData)
// console.log(densestContour)
// console.log([...densestContour.coordinates[0][0]])

// const referenceLineData = [[0, 0], [axisSyncDomain, axisSyncDomain]]; // Adjust points as needed
// const lineGenerator2 = d3.line()
//   .x(d => d[0])
//   .y(d => d[1]);

// svg.append("path")
// .attr("class", "tryerLine")
//   .attr("d", lineGenerator2([...densestContour.coordinates[0][0]]))
//   .attr("stroke", "red") // Adjust color as needed
//   .attr("stroke-dasharray", "5,5"); // Optional: dashed line


// // Calculate the centroid of the densest contour
// // const centroid = d3.polygonCentroid(densestContour.coordinates[0][0]);
// const centroid = d3.polygonCentroid([...densestContour.coordinates[0][0]]);
// console.log(centroid)
// // Convert centroid coordinates to pixel coordinates
// const x = xAxis(centroid[0]);
// const y = yAxis(centroid[1]);

// console.log("Densest location coordinates:",x,y, centroid[0], centroid[1]);


// // Define annotation for densest location
// var annotations = [{
//   note: {
//     label: "Densest Location",
//     title: 'Densest number of country'
//   },
//   x: centroid[0], // Use calculated x directly
//   y: centroid[1], // Use calculated y directly
//   dy: 100,
//   dx: 250,
//   className: "show-bg",
//   subject: { radius: 50, radiusPadding: -50 },
//   color: ['red'],
//   connector:{end: "arrow"}
// }]


// const makeAnnotations = d3.annotation()
//   .editMode(true)
//   .notePadding(15)
//   .type(type)
//   .annotations(annotations)

// // makeAnnotations.annotations([
// //     {
// //       ...densestAnnotation,
// //       x: d => x,
// //       y: d => y,
// //     }
// //   ]);

// svg.append("g")
//   .attr("class", "annotation-group")
//   .call(makeAnnotations.annotations(annotations));


// Top 3 density countour annotation
// Sort the densityData by value in descending order
var sortedDensityData = densityData.sort((a, b) => b.value - a.value);
// Get the top 3 densest contours
// var top3DensestContours = sortedDensityData.slice(0, 3);
console.log (sortedDensityData)
var top3DensestContours = [];
 top3DensestContours= [sortedDensityData[0],sortedDensityData[parseInt((sortedDensityData.length)/2)],sortedDensityData[sortedDensityData.length-1]];
console.log (top3DensestContours)
var top3Centroid = [];

for (const contour of top3DensestContours) {
    console.log ('computing top3Centroid for: ', year, contour)
    console.log ('computing top3Centroid for: ', year, contour['coordinates'])
    let countourGroup=[...contour.coordinates[0]];
    console.log (countourGroup)
    let tempCoordinates=[];
    tempCoordinates=await d3.polygonCentroid(...countourGroup);
    console.log (tempCoordinates)
    top3Centroid.push(tempCoordinates);
    }
    console.log(top3Centroid)
console.log(top3DensestContours)
console.log (top3Centroid)
await globalTop3Centroid.push(top3Centroid)
console.log(globalTop3Centroid)

var referenceny=50
var referencenx=50

var annotations = [{
  note: {
    label: "HIGHEST density number of country",
    title: year
  },
  x: top3Centroid[0][0], // Use calculated x directly
  y: top3Centroid[0][1], // Use calculated y directly
  nx: xAxis(referencenx-10),
  ny: yAxis(referenceny-40),
  className: "show-bg",
  subject: { radius: 50, radiusPadding: -50 },
  color: ['red'],
  connector:{end: "arrow"}
},
{
  note: {
    label: 'MEDIAN density of number of country',
    title: year
  },
  x: top3Centroid[1][0], // Use calculated x directly
  y: top3Centroid[1][1], // Use calculated y directly
  nx: xAxis(referencenx-5),
  ny: yAxis(referenceny-25),
  className: "show-bg",
  subject: { radius: 30, radiusPadding: -30 },
  color: ['maroon'],
  connector:{end: "arrow"}
},
{
  note: {
    label: 'LOWEST density of number of country',
    title: year
  },
  x: top3Centroid[2][0], // Use calculated x directly
  y: top3Centroid[2][1], // Use calculated y directly
  nx: xAxis(referencenx-0),
  ny: yAxis(referenceny-10),
  className: "show-bg",
  subject: { radius: 10, radiusPadding: -10 },
  color: ['orange'],
  connector:{end: "arrow"}
}
]

const makeAnnotations = d3.annotation()
  .editMode(true)
  .notePadding(15)
  .type(type)
  .annotations(annotations)

  var localAnnotationVariables= svg.append("g")
  .attr("class", "annotation-group")
  .call(await makeAnnotations.annotations(annotations));

  //Inspired and adapted from https://stackoverflow.com/questions/70415772/d3-js-animate-a-circle-along-x-y-coordinates
  // add path

  console.log ('globalTop3Centroid before annotation for loop is: ',globalTop3Centroid)
for (const iter of globalTop3Centroid){
    console.log (iter)

    if (!globalMedian3Centroid.includes(iter[1]))
    {
        globalMedian3Centroid.push(iter[1]);
        console.log (globalMedian3Centroid)
    }
    
}
console.log ('globalTop3Centroid is: ', globalTop3Centroid)
console.log ('globalMedian3Centroid is: ', globalMedian3Centroid)

const animationPathGenerator = d3.line()
          .x(d => d[0])
          .y(d => d[1]);

  const annotationTracePath = await svg.append('path')
          .attr('d', animationPathGenerator(globalMedian3Centroid))
          .attr('stroke', 'red')
          .attr('fill', 'none');

      // draw circle at initial location


    console.log (localAnnotationVariables)
    console.log(annotationTracePath.node())

      // animate
      globalCircle.raise().transition()
          .ease(d3.easeLinear)
          .duration(5000)
          .attrTween('transform', translateAlong(annotationTracePath.node()));

      // https://bl.ocks.org/mbostock/1705868
      function translateAlong(path) {
        const length = path.getTotalLength();
        return function() {
          return function(t) {
            const {x, y} = path.getPointAtLength(t * length);
            return `translate(${x},${y})`;
          }
        }
      }





//Create timeline bar


console.log ('end of mainRendering function')
}












</script>
</body>

</html>